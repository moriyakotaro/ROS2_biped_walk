#!/usr/bin/env python3
# coding: utf-8

import math
import numpy as np
import rclpy
from rclpy.node import Node
from visualization_msgs.msg import Marker
from builtin_interfaces.msg import Duration

class SimpleSimulator(Node):
    def __init__(self):
        super().__init__('simple_simulator')
        
        self.gravity = 9.8  # m/s2
        self.delta_time = 0.01  # s
        self.centroid_height = 0.5  # m

        # パラメータを宣言
        self.declare_parameter('step_time', 0.5)
        self.declare_parameter('initial_centroid_x', 0.0)
        self.declare_parameter('initial_centroid_y', 0.04)
        self.declare_parameter('initial_step_x', 0.0)
        self.declare_parameter('initial_step_y', 0.05)

        # パラメータの取得
        self.step_time = self.get_parameter('step_time').get_parameter_value().double_value
        initial_centroid_x = self.get_parameter('initial_centroid_x').get_parameter_value().double_value
        initial_centroid_y = self.get_parameter('initial_centroid_y').get_parameter_value().double_value
        initial_step_x = self.get_parameter('initial_step_x').get_parameter_value().double_value
        initial_step_y = self.get_parameter('initial_step_y').get_parameter_value().double_value

        # 歩行データの設定（固定値として設定）
        self.ref_step_data = np.array([
            [0.1, 0.1, 0.0],
            [0.1, 0.1, 0.0],
            [0.1, 0.1, 0.0],
            [0.1, 0.1, 0.0],
            [0.1, 0.1, 0.0],
            [0.1, 0.1, 0.0],
            [0.1, 0.1, 0.0],
            [0.1, 0.1, 0.0],
            [0.1, 0.1, 0.0]
        ], dtype=np.float32)

        self.centroid_position = np.array([initial_centroid_x, initial_centroid_y], dtype=np.float32)
        self.centroid_velocity = np.array([0, 0], dtype=np.float32)

        self.step_position = np.array([initial_step_x, initial_step_y], dtype=np.float32)
        self.ref_step_position = np.array([initial_step_x, initial_step_y], dtype=np.float32)

        self.step_count = 0

        # ROS2 パブリッシャーの作成
        self.vis_pub = self.create_publisher(Marker, '/centroid', 10)
        
        # タイマーの作成（delta_timeごとに実行）
        self.timer = self.create_timer(self.delta_time, self.timer_callback)
        
        # シミュレーション状態管理
        self.simulation_step = 0
        self.step_iteration = 0
        self.max_step_iterations = int(self.step_time / self.delta_time)
        self.simulation_finished = False

        self.get_logger().info(f'SimpleSimulator initialized with step_time: {self.step_time}')

    def publish_marker(self, idx, position, scale, color=(1.0, 0.0, 0.0, 1.0)):
        marker = Marker()

        marker.header.frame_id = "map"
        marker.header.stamp = self.get_clock().now().to_msg()

        marker.ns = 'inverted_pendulum'
        marker.id = idx

        marker.action = Marker.ADD

        marker.pose.position.x = float(position[0])
        marker.pose.position.y = float(position[1])
        marker.pose.position.z = float(position[2])

        marker.pose.orientation.x = 0.0
        marker.pose.orientation.y = 0.0
        marker.pose.orientation.z = 1.0
        marker.pose.orientation.w = 0.0

        marker.scale.x = scale[0]
        marker.scale.y = scale[1]
        marker.scale.z = scale[2]

        marker.color.r = color[0]
        marker.color.g = color[1]
        marker.color.b = color[2]
        marker.color.a = color[3]

        # ROS2では Duration の設定方法が異なる
        marker.lifetime = Duration()

        marker.type = Marker.SPHERE

        self.vis_pub.publish(marker)

    def timer_callback(self):
        if self.simulation_finished:
            return

        if self.simulation_step >= len(self.ref_step_data) + 1:
            self.get_logger().info('Simulation finished')
            self.simulation_finished = True
            return

        # 支持脚の描写
        position = [self.step_position[0], self.step_position[1], 0.0]
        self.publish_marker(idx=0, position=position, scale=(0.02, 0.02, 0.01))

        # 線形倒立振子の方程式を積分して重心運動を計算
        if self.step_iteration < self.max_step_iterations:
            centroid_acceleration = self.gravity / self.centroid_height * (self.centroid_position - self.step_position)
            self.centroid_velocity += centroid_acceleration * self.delta_time
            self.centroid_position += self.centroid_velocity * self.delta_time

            # 重心運動の描写
            position = [self.centroid_position[0], self.centroid_position[1], self.centroid_height]
            self.publish_marker(idx=1, position=position, scale=(0.04, 0.04, 0.04))

            self.step_iteration += 1
        else:
            # 1歩完了、次の歩行ステップへ
            self.update_step()
            self.step_iteration = 0
            self.simulation_step += 1

    def update_step(self):
        # 1歩更新
        self.step_count += 1

        # 次の目標着地点を求める
        if self.step_count - 1 >= len(self.ref_step_data):
            current_ref_step_data = np.array([0, 0, 0], dtype=np.float32)
        else:
            current_ref_step_data = self.ref_step_data[self.step_count - 1]
        
        current_ref_step_angle = current_ref_step_data[2]
        current_ref_step_size = np.array([
            current_ref_step_data[0] * np.cos(current_ref_step_angle) - current_ref_step_data[1] * np.sin(current_ref_step_angle),
            current_ref_step_data[0] * np.sin(current_ref_step_angle) + current_ref_step_data[1] * np.cos(current_ref_step_angle)
        ])
        self.ref_step_position = self.ref_step_position + current_ref_step_size

        # 次の1歩行周期後の重心座標と重心速度の目標値を求める
        if self.step_count >= len(self.ref_step_data):
            next_ref_step_data = np.array([0, 0, 0], dtype=np.float32)
        else:
            next_ref_step_data = self.ref_step_data[self.step_count]
        
        next_ref_step_angle = next_ref_step_data[2]
        next_ref_step_size = np.array([
            next_ref_step_data[0] * np.cos(next_ref_step_angle) - next_ref_step_data[1] * np.sin(next_ref_step_angle),
            next_ref_step_data[0] * np.sin(next_ref_step_angle) + next_ref_step_data[1] * np.cos(next_ref_step_angle)
        ])

        Tc = math.sqrt(self.centroid_height / self.gravity)
        C = math.cosh(self.step_time / Tc)
        S = math.sinh(self.step_time / Tc)

        h_xy = next_ref_step_size / 2
        h_v_xy = np.array((
            (C + 1) / (Tc * S) * h_xy[0],
            (C - 1) / (Tc * S) * h_xy[1]
        ), dtype=np.float32)
        next_target_position = self.ref_step_position + h_xy
        next_target_velocity = h_v_xy

        # 次の修正した着地点を求める
        a = 10.0
        b = 1.0
        D = a * (C - 1)**2 + b * (S / Tc)**2

        xyi = self.centroid_position
        vxyi = self.centroid_velocity
        xyd = next_target_position
        vxyd = next_target_velocity
        next_step_position = -a * (C - 1) / D * (xyd - C * xyi - Tc * S * vxyi) - b * S / (Tc * D) * (vxyd - S / Tc * xyi - C * vxyi)
        self.step_position = next_step_position

def main(args=None):
    rclpy.init(args=args)
    
    simulator = SimpleSimulator()
    
    try:
        rclpy.spin(simulator)
    except KeyboardInterrupt:
        simulator.get_logger().info('Simulation interrupted by user')
    finally:
        simulator.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
